
#include "game/mobile.h"
#include "game/world.h"
#include "muls/tiledata.h"

// Draw order for layers dependant on direction facing
// -1 terminates
static const int drawOrder[8][25] = {
	{5, 4, 3, 24, 23, 13, 19, 17, 22, 12, 14, 8, 7, 1, 2, 10, 16, 11, 18, 6, 20, 21, -1},
	{5, 4, 3, 24, 23, 13, 19, 17, 22, 12, 14, 8, 7, 1, 2, 10, 16, 11, 18, 6, 20, 21, -1},
	{5, 4, 3, 24, 23, 13, 19, 17, 22, 12, 14, 8, 7, 1, 2, 10, 16, 11, 18, 6, 20, 21, -1},
	{20, 5, 4, 3, 24, 23, 13, 19, 17, 22, 12, 14, 8, 7, 1, 2, 10, 16, 11, 18, 6, 21, -1},
	{20, 5, 4, 3, 24, 23, 13, 19, 17, 22, 12, 14, 8, 7, 1, 2, 10, 16, 11, 18, 6, 21, -1},
	{20, 5, 4, 3, 24, 23, 13, 19, 17, 22, 12, 14, 8, 7, 1, 2, 10, 16, 11, 18, 6, 21, -1},
	{5, 4, 3, 24, 23, 13, 19, 17, 22, 12, 14, 8, 7, 1, 2, 10, 16, 11, 18, 6, 20, 21, -1},
	{5, 4, 3, 24, 23, 13, 19, 17, 22, 12, 14, 8, 7, 1, 2, 10, 16, 11, 18, 6, 20, 21, -1}
};

cMobile::cMobile(unsigned short x, unsigned short y, signed char z, enFacet facet, unsigned int serial) : cDynamicEntity(x, y, z, facet, serial) {
	body_ = 1;
	hue_ = 0;
	direction_ = 0;
	partialHue_ = false;
	type_ = MOBILE;
	sequence_ = 0;
	currentAction_ = getIdleAction();
	currentActionEnd_ = 0;
	nextFrame = 0;
	frame = 0;
	smoothMoveEnd = 0;

	for (int i = 0; i < LAYER_VISIBLECOUNT; ++i) {
		equipmentSequences[i] = 0;
	}
}

void cMobile::setSerial(unsigned int serial) {
	World->unregisterDynamic(this);
	serial_ = serial;
	World->registerDynamic(this);
}

void cMobile::smoothMove(int xoffset, int yoffset, unsigned int duration) {
	drawxoffset = xoffset;
	drawyoffset = yoffset;
	smoothMoveTime = duration;
	smoothMoveEnd = Utilities::getTicks() + duration;
}

cMobile::~cMobile() {
	freeSequence();

	if (this == Player) {
		Player = 0; // Reset player to null -> important
	}
}

void cMobile::playAction(unsigned char action, unsigned int duration) {
	if (currentAction_ != action) {
		freeSequence(); // Free old sequence if the actions dont match
	}

	// Set the action and the duration
	currentAction_ = action;
	currentActionEnd_ = Utilities::getTicks() + duration;
}

void cMobile::freeSequence() {
	if (sequence_) {
		sequence_->decref();
		sequence_ = 0;
	}

	for (int i = 0; i < LAYER_VISIBLECOUNT; ++i) {
		if (equipmentSequences[i]) {
			equipmentSequences[i]->decref();
			equipmentSequences[i] = 0;
		}
	}
}

void cMobile::refreshSequence() {
	if (sequence_) {
		sequence_->decref();
	}

	sequence_ = Animations->readSequence(body_, currentAction_, direction_, hue_, partialHue_);	
	
	// Try to maintain the flow of the animation
	if (sequence_ && frame >= sequence_->frameCount()) {
		frame = 0;
		nextFrame = Utilities::getTicks() + getFrameDelay();
	}

	QList<stEquipInfo>::const_iterator it;
	for (it = equipment.begin(); it != equipment.end(); ++it) {
		// Load Sequence for this
		if (equipmentSequences[it->layer]) {
			equipmentSequences[it->layer]->decref();
		}

		cItemTileInfo *tinfo = Tiledata->getItemInfo(it->id);

		if (tinfo && tinfo->animation()) {
			unsigned short model = tinfo->animation();
			bool partialHue = tinfo->isPartialHue();
			equipmentSequences[it->layer] = Animations->readSequence(model, currentAction_, direction_, it->hue, partialHue);
		} else {
			equipmentSequences[it->layer] = 0;
		}
	}
}

unsigned int cMobile::getFrameDelay() {
	return 370;
}

unsigned char cMobile::getIdleAction() {
	return 0;
}

void cMobile::draw(int cellx, int celly, int leftClip, int topClip, int rightClip, int bottomClip) {
	// See if the current action expired
	if (currentActionEnd_ != 0 && currentActionEnd_ < Utilities::getTicks()) {
		freeSequence(); // Free current surface
		currentActionEnd_ = 0; // Reset end time
		currentAction_ = getIdleAction();
	}

	// Refresh the sequence
	if (!sequence_) {
		refreshSequence();
	}

	// Modify cellx/celly based on the smooth move settings
	// Smooth move handling.
	if (smoothMoveEnd != 0) {
		int moveProgress = smoothMoveTime - (smoothMoveEnd - Utilities::getTicks());
		if (moveProgress < 0 || moveProgress >= (int)smoothMoveTime) {
			smoothMoveEnd = 0;
		} else {
			if (moveProgress <= 0) {
				cellx += drawxoffset;
				celly += drawyoffset;
				frame = 0;
			} else {
				float factor = 1.0f - (float)moveProgress / (float)smoothMoveTime;
				cellx += (int)(factor * (float)drawxoffset);
				celly += (int)(factor * (float)drawyoffset);
				if (sequence_) {
					frame = (int)(sequence_->frameCount() * factor);
				}
			}
		}
	}

	// Draw
	if (sequence_) {
		// Skip to next frame
		if (smoothMoveEnd == 0 && nextFrame < Utilities::getTicks()) {
			if (++frame >= sequence_->frameCount()) {
				frame = 0;
			}
			nextFrame = Utilities::getTicks() + getFrameDelay();
		}
		
		// The anims facing right are generated by flipping the ones facing left
		bool flip = (direction_ > 0 && direction_ < 4);
		sequence_->draw(frame, cellx, celly, flip);

		// Draw the equipment
		const int *order = drawOrder[direction_ % 8];
		while (*order != -1) {
			enLayer layer = (enLayer)*order;

			if (layer < LAYER_VISIBLECOUNT && equipmentSequences[layer]) {
				equipmentSequences[layer]->draw(frame, cellx, celly, flip);
			}

			++order; // Next layer
		}
	}
}

bool cMobile::hitTest(int x, int y) {
	return false;
}

void cMobile::updatePriority() {
	priority_ = z_ + 2;
}

void cMobile::addEquipment(unsigned int serial, unsigned short id, unsigned short hue, enLayer layer) {
	stEquipInfo info;
	info.serial = serial;
	info.hue = hue;
	info.id = id;
	info.layer = layer;
	equipment.append(info);

	// Load Sequence for this
	if (equipmentSequences[layer]) {
		equipmentSequences[layer]->decref();
	}

	cItemTileInfo *tinfo = Tiledata->getItemInfo(id);

	if (tinfo && tinfo->animation()) {
		unsigned short model = tinfo->animation();
		bool partialHue = tinfo->isPartialHue();
		equipmentSequences[layer] = Animations->readSequence(model, currentAction_, direction_, hue, partialHue);
	} else {
		equipmentSequences[layer] = 0;
	}
}

cMobile *Player = 0;
